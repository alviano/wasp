<!DOCTYPE html>
<html lang="en-us">
    <head>
    <meta charset="UTF-8">
    <title>Wasp by alviano</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    </head>
    <body>
        <section class="page-header">
            <h1 class="project-name">Wasp</h1>
            <h2 class="project-tagline"></h2>
            <a href="index.html" class="btn">Home</a>
            <a href="https://github.com/alviano/wasp" class="btn">View on GitHub</a>
            <a href="https://github.com/alviano/wasp/zipball/master" class="btn">Download .zip</a>
            <a href="https://github.com/alviano/wasp/tarball/master" class="btn">Download .tar.gz</a>
            <a href="index.html#publications" class="btn">Publications</a>
            <a href="plugins-documentation.html" class="btn">Documentation</a>
        </section>

        <section class="main-content">
            <h1><a id="wasp" class="anchor" href="#wasp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation</h1>
            <p>
The communication between wasp and the external propagators follows a synchronous message passing protocol.
The protocol is implemented by means of method calls. Basically, the propagator must be compliant with a specific interface described below.
Whenever a specific point of the computation is reached the corresponding method of the propagator is called, e.g. when a literal is true the method onLiteralTrue is called.
Some of the methods of the interface are allowed to return values that are interpreted by WASP.
            </p>


            <hr/>
            <p><b>Method</b>: setScriptDirectory(id, dirname) - <b>Return</b>: -
            <ul>
                <li><i>id:</i> an integer representing the id of the directory. At the moment this is a (useless) integer equal to 0 since only directory can be specified.</li>
                <li><i>dirname:</i> the current directory of the script.</li>
            </ul>
            This method is invoked before starting and specifies the current directory of the python script.<br/> <br/>

            <b>Note:</b> Optional.
            </p>

            <hr/>
            <p><b>Method</b>: addedVarName(id, name) - <b>Return</b>: -
            <ul>
                <li><i>id:</i> an integer representation of a variable.</li>
                <li><i>name:</i> the name associated to the id.</li>
            </ul>
            This method is invoked while reading the name associated to an atom. <br/> <br/>

            <b>Note:</b> Optional. Try <a href="https://www.mat.unical.it/DLV2">DLV2</a> for a convenient way to avoid this method.
            </p>
            <hr/>

            <p><b>Method</b>: getLiterals(*lits) - <b>Return</b>: L
            <ul>
                <li><i>lits:</i> a list of literals derived as true during the parsing. The first element of the list is the number of variables used in wasp. Literal 1 is always false.</li>
                <li><i>L: </i> a list of integers.</li>
            </ul>
            This method returns a list of literals L attached to the propagator, i.e. when a literal in L is derived as true a notification is sent to the propagator using either method onLiteralTrue or method onLiteralsTrue.<br/> <br/>

            <b>Note:</b> Required only if one between onLiteralTrue and onLiteralsTrue is used. Otherwise, it is optional.
            </p>
            <hr/>

            <p><b>Method</b>: onVariableElimination(var)  - <b>Return</b>: -
            <ul>
                <li><i>var:</i> a positive integer representing the id of a variable.</li>
            </ul>            
            This method is invoked when the variable is removed by clause rewriting. <br/> <br/>
            <b>Note: </b>  Optional.
            </p>
            <hr/>

            <p><b>Method</b>: simplifyAtLevelZero() - <b>Return</b>: L
            <ul>
                <li><i>L:</i> a list of literals.</li>
            </ul>            
            This method is invoked before starting the search and returns a list of literals L to be inferred as deterministic consequence. In order to trigger an incoherence add "1" to L. <br/> <br/>
            <b>Note:</b>  Optional.
            </p>
            <hr/>

            <p><b>Method</b>: onStartingSolver() <b>Return</b>: - <br/><br/>
            This method is invoked when the computation starts. After this point all the simplifications are done.<br/> <br/>

            <b>Note:</b> Optional.
            </p>
            <hr/>

            <p><b>Method</b>: onLiteralTrue(lit, dl) - <b>Return</b>: L
            <ul>
                <li><i>lit:</i> a literal whose truth value is true.</li>
                <li><i>dl:</i> a positive integer representing the decision level of the solver.</li>
                <li><i>L:</i> a list of literals.</li>
            </ul>
            This method is invoked whenever a literal becomes true by propagation or by choice. Returns a list of literals L to infer as true. Afterward, the method getReason (or getReasonForLiteral) is invoked. <br/> <br/>

            <b>Note:</b> Required if checkAnswerSet is not used. Otherwise, it is optional. Exactly one between onLiteralTrue and onLiteralsTrue is required.
            </p>
            <hr/>

            <p><b>Method</b>: onLiteralsTrue(*lits)  - <b>Return</b>: L
            <ul>
                <li><i>lits:</i> a list of literals that are true. The first element of the list is the current decision level of the solver.</li>
                <li><i>L:</i> a list of literals.</li>
            </ul>
            This method is invoked after unit propagation and notifies all literals that become true by propagation and by choice. Returns a list of literals L to infer as true. Afterward, the method getReason (or getReasonForLiteral) is invoked.<br/> <br/>

            <b>Note:</b> Required if checkAnswerSet is not used. Otherwise, it is optional. Exactly one between onLiteralTrue and onLiteralsTrue is required.
            </p>
            <hr/>

            <p><b>Method</b>: endPropagation(dl) - <b>Return</b>: L
            <ul>
                <li><i>dl:</i> a positive integer representing the current decision level of the solver.</li>
                <li><i>L:</i> a list of literals.</li>
            </ul>
            This method is invoked after all propagations are done. It can be used to postpone the propagation of some of the literals. Returns a list of literals L to infer as true. Afterward, the method getReason (getReasonForLiteral) is invoked. <br/> <br/>

            <b>Note:</b> It can be used only if onLiteralTrue is used.
            </p>
            <hr/>

            <p><b>Method</b>: getReason() - <b>Return</b>: S
            <ul>
                <li><i>S:</i> a set of literals.</li>
            </ul>
            This method returns a clause modeling the reason for the assignments made by onLiteralTrue (onLiteralsTrue). That is, let P = {p1;...;pm} be the literals returned by onLiteralTrue (onLiteralsTrue), and the reason is of the form l1 ^ ... ^ ln -> p (for each p in P). Then, S={-l1;...;-ln}.<br/> <br/>

            <b>Note:</b> Required only if one between onLiteralTrue and onLiteralsTrue is used. Otherwise, it is useless. Exactly one between getReason and getReasonForLiteral is required.
            </p>
            <hr/>

            <p><b>Method</b>: getReasonForLiteral(lit)  - <b>Return</b>: S
            <ul>
                <li><i>lit:</i> one of the literals inferred as true by onLiteralTrue (onLiteralsTrue).</li>
                <li><i>S: </i> a set of literals.</li>
            </ul>
            This method returns a clause modeling the reason for the assignment of one literal. That is, if the reason is of the form l1 ^ ... ^ ln -> lit. Then, S={-l1;...;-ln}.<br/> <br/>

            <b>Note:</b> Required only if one between onLiteralTrue and onLiteralsTrue is used. Otherwise, it is useless. Exactly one between getReason and getReasonForLiteral is required.
            </p>
            <hr/>

            <p><b>Method</b>: onLiteralsUndefined(*lits)  - <b>Return</b>: -
            <ul>
                <li><i>lits:</i> a list representing the undefined literals. The first element of lits is the current decision level of the solver.</li>
            </ul>
            This method is invoked when some of the literals notified as true are again undefined (e.g. after an unroll or a restart). <br/> <br/>

            <b>Note:</b> Required only if one between onLiteralTrue and onLiteralsTrue is used. Otherwise, it is optional.
            </p>
            <hr/>

            <p><b>Method</b>: checkAnswerSet(*lits) - <b>Return</b>: i
            <ul>
                <li><i>lits:</i> a list of literals representing the answer set.</li>
                <li><i>i: </i> an integer.</li>
            </ul>
            This method is invoked after an answer set is found. The role of the method is to check whether the answer set is consistent with the propagator. Returns 0 if the answer set is inconsistent, !=0 otherwise.<br/> <br/>

            <b>Note:</b> Required only if onLiteralTrue and onLiteralsTrue are not used. Otherwise, it is optional.
            </p>
            <hr/>

            <p><b>Method</b>: checkPartialInterpretation(*lits) - <b>Return</b>: i
            <ul>
                <li><i>lits:</i> a list of literals representing the partial interpretation.</li>
                <li><i>i: </i> an integer.</li>
            </ul>
            This method is invoked after each propagation. The role of the method is to check whether the interpretation is consistent with the propagator. Returns 0 if the interpretation is inconsistent, !=0 otherwise. <br/> <br/>

            <b>Note:</b> Optional.
            </p>
            <hr/>

            <p><b>Method</b>: getReasonsForCheckFailure()  - <b>Return</b>: L
            <ul>
                <li><i>L:</i> a list of clauses.</li>
            </ul>
            This method is invoked after a failure of checkAnswerSet or checkPartialInterpretation. It returns a list of clauses modeling the reasons for the failure. Each clause is a set of literals S={l1;...;ln} interpreted as l1 v ... v ln.
The clauses must be separated by 0. Note that the first and the last element of the list are expected to be equal to 0.
If you import the library wasp.py you can simply use wasp.createReasonsForCheckFailure(clauses). See running examples for more details.<br/><br/>

            <b>Note:</b> Required only if checkAnswerSet or checkPartialInterpretation are used.
            </p>
            <hr/>

            <p><b>Method</b>: onNewLowerBound(lb) - <b>Return</b>: -
            <ul>
                <li><i>lb:</i> a positive integer representing the lower bound.</li>
            </ul>
            This method is invoked only on optimization problems whenever a new lower bound of the optimum solution is found.<br/> <br/>

            <b>Note:</b> Optional.
            </p>
            <hr/>

            <p><b>Method</b>: onNewUpperBound(ub) - <b>Return</b>: -
            <ul>
                <li><i>ub:</i> a positive integer representing the upper bound.</li>
            </ul>
            This method is invoked only on optimization problems whenever a new upper bound of the optimum solution is found.<br/> <br/>

            <b>Note:</b> Optional.
            </p>
            <hr/>

            <p><b>Method</b>: addWeakConstraints(*lits)  - <b>Return</b>: L
            <ul>
                <li><i>lits:</i> a list of literals representing the answer set.</li>
                <li><i>L:</i> a list of soft clauses.</li>
            </ul>
            This method is used to lazily add weak constraints (you have to enable the option --lazy-weakconstraints). The method is invoked after an answer set is found and it returns a list of soft clauses modeling the weak constraints to add. Each soft clause is a set of literals S={l1;...;ln} interpreted as l1 v ... v ln.
The soft clauses must be separated by 0. Note that the first and the last element of the list are expected to be equal to 0.
If you import the library wasp.py you can simply use wasp.createWeakConstraints(softClauses). See running examples for more details.<br/> <br/>
            <b>Note:</b> Optional.

            <p><b>Method</b>: addWeightsForWeakConstraints()  - <b>Return</b>: L
            <ul>
                <li><i>L:</i> a list of weights associated to each soft clause.</li>
            </ul>
            This method is invoked after addWeakConstraints and returns a list of positive weights associated to each soft clause. Note that the i-th soft clause is associated with the i-th weight.
Moreover, the weights must be long, so if you are using python2 you have to explicit add long(e) for each element e in L. If you import the library wasp.py you can simply use wasp.createWeights(weights). See running examples for more details.<br/> <br/>

            <b>Note:</b> Required if addWeakConstraints is used. Otherwise, it is optional.
            </p>
            <hr/>
            <h1><a id="wasp" class="anchor" href="#wasp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Description of the module wasp (file wasp.py)</h1>
The module wasp can be used to simplify the interaction with the solver.
<hr/>
            <p><b>Method</b>: createReasonsForCheckFailure(clauses) - <b>Return</b>: L
            <ul>
                <li><i>clauses:</i> a list of clauses, where a clause is a list of integers.</li>
            </ul>
            This method takes as input a list of clauses and produces a list that can be interpreted by wasp as reasons for the check failure.
            </p>
<hr/>
            <p><b>Method</b>: createWeakConstraints(weak) - <b>Return</b>: L
            <ul>
                <li><i>weak:</i> a list of soft clauses, where a soft clause is a list of integers.</li>
            </ul>
            This method takes as input a list of soft clauses and produces a list that can be interpreted by wasp as weak constraints.
            </p>
<hr/>
            <p><b>Method</b>: createWeights(weights) - <b>Return</b>: L
            <ul>
                <li><i>weights:</i> a list of integers (long) representing the weights of the weak constraints.</li>
            </ul>
            This method converts each integer in the list weights in a long. This is useless if python3 is used.
            </p>    
<hr/>
            <p><b>Method</b>: fromNogood(conj) - <b>Return</b>: L
            <ul>
                <li><i>conj:</i> a list of integers representing a conjunction.</li>
            </ul>
            Converts the conjunction into a disjunction.
            </p>
<hr/>
            <p><b>Method</b>: fromLitImplConj(lit, conj) - <b>Return</b>: L
            <ul>
                <li><i>lit:</i> an integer representing a literal.</li>
                <li><i>conj:</i> a list of integers representing a conjunction.</li>
            </ul>
            Takes as input the implication lit &#8594; l<sub><small>1</small></sub> &#8743; ... &#8743; l<sub><small>n</small></sub> (for l<sub><small>1</small></sub>, ... ,l<sub><small>n</small></sub> in conj) and creates a list of clauses
<p>
 c<sub><small>1</small></sub> &#8743; ... &#8743; c<sub><small>n</small></sub>, where c<sub><small>i</small></sub> = -lit &#8744; l<sub><small>i</small></sub> (for i = 1, ... ,n).
</p>
            </p>
<hr/>
            <p><b>Method</b>: fromLitImplDisj(lit, disj) - <b>Return</b>: L
            <ul>
                <li><i>lit:</i> an integer representing a literal.</li>
                <li><i>disj:</i> a list of integers representing a disjunction.</li>
            </ul>
            Takes as input the implication lit &#8594; l<sub><small>1</small></sub> &#8744; ... &#8744; l<sub><small>n</small></sub> (for l<sub><small>1</small></sub>, ... ,l<sub><small>n</small></sub> in disj) and creates the clause -lit &#8744; l<sub><small>1</small></sub> &#8744; ... &#8744; l<sub><small>n</small></sub>.
            </p>
<hr/>
            <p><b>Method</b>: fromConjImplLit(lit, conj) - <b>Return</b>: L
            <ul>
                <li><i>lit:</i> an integer representing a literal.</li>
                <li><i>conj:</i> a list of integers representing a conjunction.</li>
            </ul>
            Takes as input the implication l<sub><small>1</small></sub> &#8743; ... &#8743; l<sub><small>n</small></sub> &#8594; lit (for l<sub><small>1</small></sub>, ... ,l<sub><small>n</small></sub> in conj) and creates the clause 
<p>
-l<sub><small>1</small></sub> &#8744; ... &#8744; -l<sub><small>n</small></sub> &#8744; lit (for l<sub><small>1</small></sub>, ... ,l<sub><small>n</small></sub> in conj).
</p>            </p>
<hr/>
            <p><b>Method</b>: fromDisjImplLit(lit, disj) - <b>Return</b>: L
            <ul>
                <li><i>lit:</i> an integer representing a literal.</li>
                <li><i>disj:</i> a list of integers representing a disjunction.</li>
            </ul>
            Takes as input the implication l<sub><small>1</small></sub> &#8744; ... &#8744; l<sub><small>n</small></sub> &#8594; lit (for l<sub><small>1</small></sub>, ... ,l<sub><small>n</small></sub> in disj) and creates a list of clauses
<p>
c<sub><small>1</small></sub> &#8743; ... &#8743; c<sub><small>n</small></sub>, where c<sub><small>i</small></sub> = lit &#8744; -l<sub><small>i</small></sub> (for i = 1, ... ,n).
</p>
           </p>
<hr/>
            <p><b>Method</b>: incoherent() - <b>Return</b>: i
            <ul>
            <li><i>i: </i> an integer.</li>
            </ul>
            Return 0 to indicate that the answer set candidate is not valid.
            </p>
<hr/>
            <p><b>Method</b>: coherent() - <b>Return</b>: i
            <ul>
            <li><i>i: </i> an integer.</li>
            </ul>
            Return 1 to indicate that the answer set candidate is valid.
            </p>
<hr/>
            <p><b>Method</b>: getTerms(predicateName,atomName) - <b>Return</b>: L
            <ul>
            <li><i>predicateName: </i> a string representing the name of the predicate.</li>
            <li><i>atomName: </i> a string representing the full name of the atom.</li>
            </ul>
            Return a list of string representing the terms. For example, given atomName="pred(1,2,hello)" and predicateName="pred", it returns ["1","2","hello"].
            </p> 
<hr/>
            <h1><a id="wasp" class="anchor" href="#wasp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running examples</h1>

            <p>Consider the following simple encoding</p>
            <pre>
<code>{a;b;c;d}.</code>
            </pre>

            <p>We want to keep answer sets where exactly two atoms among a, b, c, and d must be true. In the following we present two different python implementations.</p>


<p>Solution 1</p>
<pre style='color:#000020;background:#f6f8ff;'>interpretation <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>]</span><span style='color:#308080; '>;</span> atoms<span style='color:#308080; '>=</span><span style='color:#308080; '>[</span><span style='color:#308080; '>]</span>
<span style='color:#074726; '>TRUE</span> <span style='color:#308080; '>=</span> <span style='color:#008c00; '>1</span><span style='color:#308080; '>;</span> <span style='color:#074726; '>FALSE</span> <span style='color:#308080; '>=</span> <span style='color:#44aadd; '>-</span><span style='color:#008c00; '>1</span><span style='color:#308080; '>;</span> UNDEFINED <span style='color:#308080; '>=</span> <span style='color:#008c00; '>0</span>
countTrue <span style='color:#308080; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>;</span> countFalse <span style='color:#308080; '>=</span> <span style='color:#008c00; '>0</span>

<span style='color:#200080; font-weight:bold; '>def</span> addedVarName<span style='color:#308080; '>(</span>var<span style='color:#308080; '>,</span> name<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> atoms
    atoms<span style='color:#308080; '>.</span>append<span style='color:#308080; '>(</span>var<span style='color:#308080; '>)</span>

<span style='color:#200080; font-weight:bold; '>def</span> getLiterals<span style='color:#308080; '>(</span><span style='color:#44aadd; '>*</span>lits<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> interpretation
    <span style='color:#33cc33; '>#The first position of lits contains the number of atoms used in wasp</span>
    interpretation <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span>UNDEFINED <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> <span style='color:#400000; '>range</span><span style='color:#308080; '>(</span><span style='color:#008c00; '>0</span><span style='color:#308080; '>,</span> lits<span style='color:#308080; '>[</span><span style='color:#008c00; '>0</span><span style='color:#308080; '>]</span><span style='color:#44aadd; '>+</span><span style='color:#008c00; '>1</span><span style='color:#308080; '>)</span><span style='color:#308080; '>]</span>
    <span style='color:#33cc33; '>#Attached to all changes of the truth values</span>
    l <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#44aadd; '>-</span>i <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms<span style='color:#308080; '>]</span>
    l<span style='color:#308080; '>.</span>extend<span style='color:#308080; '>(</span>atoms<span style='color:#308080; '>)</span>
    <span style='color:#200080; font-weight:bold; '>return</span> l

<span style='color:#200080; font-weight:bold; '>def</span> getVariablesToFreeze<span style='color:#308080; '>(</span><span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#33cc33; '>#Freeze all atoms</span>
    <span style='color:#200080; font-weight:bold; '>return</span> atoms
    
<span style='color:#200080; font-weight:bold; '>def</span> onLiteralTrue<span style='color:#308080; '>(</span>lit<span style='color:#308080; '>,</span> dl<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> interpretation<span style='color:#308080; '>,</span> countTrue<span style='color:#308080; '>,</span> countFalse
    <span style='color:#33cc33; '>#Count true and false atoms and propagate if needed.</span>
    interpretation<span style='color:#308080; '>[</span><span style='color:#400000; '>abs</span><span style='color:#308080; '>(</span>lit<span style='color:#308080; '>)</span><span style='color:#308080; '>]</span> <span style='color:#308080; '>=</span> lit <span style='color:#44aadd; '>/</span> <span style='color:#400000; '>abs</span><span style='color:#308080; '>(</span>lit<span style='color:#308080; '>)</span><span style='color:#308080; '>;</span> <span style='color:#595979; '>#1 TRUE, -1 FALSE    </span>
    <span style='color:#200080; font-weight:bold; '>if</span> lit <span style='color:#44aadd; '>>=</span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>:</span>
        countTrue <span style='color:#44aadd; '>+</span><span style='color:#308080; '>=</span> <span style='color:#008c00; '>1</span>
    <span style='color:#200080; font-weight:bold; '>else</span><span style='color:#308080; '>:</span>
        countFalse <span style='color:#44aadd; '>+</span><span style='color:#308080; '>=</span> <span style='color:#008c00; '>1</span>
    output <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>if</span> countTrue <span style='color:#44aadd; '>==</span> <span style='color:#008c00; '>2</span><span style='color:#308080; '>:</span>
        output <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#44aadd; '>-</span>i <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> interpretation<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span><span style='color:#44aadd; '>==</span>UNDEFINED<span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>elif</span> countFalse <span style='color:#44aadd; '>==</span> <span style='color:#008c00; '>2</span><span style='color:#308080; '>:</span>
        output <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span>i <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> interpretation<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span><span style='color:#44aadd; '>==</span>UNDEFINED<span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>return</span> output

<span style='color:#200080; font-weight:bold; '>def</span> getReason<span style='color:#308080; '>(</span><span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#33cc33; '>#Let T={a,b} be the true atoms, then the reason for the assignment is a ^ b (clause -a v -b).</span>
    reason<span style='color:#308080; '>=</span><span style='color:#308080; '>[</span><span style='color:#308080; '>]</span>    
    <span style='color:#200080; font-weight:bold; '>if</span> countTrue <span style='color:#44aadd; '>==</span> <span style='color:#008c00; '>2</span><span style='color:#308080; '>:</span>
        reason<span style='color:#308080; '>=</span><span style='color:#308080; '>[</span><span style='color:#44aadd; '>-</span>i <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> interpretation<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span><span style='color:#44aadd; '>==</span><span style='color:#074726; '>TRUE</span><span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>else</span><span style='color:#308080; '>:</span>
        reason<span style='color:#308080; '>=</span><span style='color:#308080; '>[</span>i <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> interpretation<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span><span style='color:#44aadd; '>==</span><span style='color:#074726; '>FALSE</span><span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>return</span> reason

<span style='color:#200080; font-weight:bold; '>def</span> onLiteralsUndefined<span style='color:#308080; '>(</span><span style='color:#44aadd; '>*</span>lits<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> interpretation<span style='color:#308080; '>,</span> countTrue<span style='color:#308080; '>,</span> countFalse
    <span style='color:#33cc33; '>#If a literal is again undefined the interpretation is restored.</span>
    <span style='color:#200080; font-weight:bold; '>for</span> i<span style='color:#308080; '>,</span> l <span style='color:#200080; font-weight:bold; '>in</span> <span style='color:#400000; '>enumerate</span><span style='color:#308080; '>(</span>lits<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
        <span style='color:#200080; font-weight:bold; '>if</span> i <span style='color:#44aadd; '>==</span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>:</span>    <span style='color:#200080; font-weight:bold; '>continue</span>
        <span style='color:#200080; font-weight:bold; '>if</span> l <span style='color:#44aadd; '>>=</span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>:</span>    countTrue <span style='color:#44aadd; '>-</span><span style='color:#308080; '>=</span> <span style='color:#008c00; '>1</span>
        <span style='color:#200080; font-weight:bold; '>else</span><span style='color:#308080; '>:</span>    countFalse <span style='color:#44aadd; '>-</span><span style='color:#308080; '>=</span> <span style='color:#008c00; '>1</span>
        interpretation<span style='color:#308080; '>[</span><span style='color:#400000; '>abs</span><span style='color:#308080; '>(</span>l<span style='color:#308080; '>)</span><span style='color:#308080; '>]</span> <span style='color:#308080; '>=</span> UNDEFINED
    <span style='color:#200080; font-weight:bold; '>return</span>
</pre>

<p>Solution 2</p>

<pre style='color:#000020;background:#f6f8ff;'><span style='color:#200080; font-weight:bold; '>import</span> wasp

answer <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>]</span><span style='color:#308080; '>;</span> atoms <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>]</span>

<span style='color:#200080; font-weight:bold; '>def</span> addedVarName<span style='color:#308080; '>(</span>var<span style='color:#308080; '>,</span> name<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> atoms
    atoms<span style='color:#308080; '>.</span>append<span style='color:#308080; '>(</span>var<span style='color:#308080; '>)</span>

<span style='color:#200080; font-weight:bold; '>def</span> checkAnswerSet<span style='color:#308080; '>(</span><span style='color:#44aadd; '>*</span>answer_set<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> answer
    <span style='color:#33cc33; '>#Check whether the answer set has exactly two atoms true</span>
    count <span style='color:#308080; '>=</span> <span style='color:#400000; '>sum</span><span style='color:#308080; '>(</span><span style='color:#308080; '>[</span><span style='color:#008c00; '>1</span> <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> answer_set<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span> <span style='color:#44aadd; '>></span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>]</span><span style='color:#308080; '>)</span>
    <span style='color:#200080; font-weight:bold; '>if</span> count <span style='color:#44aadd; '>!=</span> <span style='color:#008c00; '>2</span><span style='color:#308080; '>:</span>
        answer <span style='color:#308080; '>=</span> answer_set
        <span style='color:#200080; font-weight:bold; '>return</span> wasp<span style='color:#308080; '>.</span>incoherent<span style='color:#308080; '>(</span><span style='color:#308080; '>)</span>
    <span style='color:#200080; font-weight:bold; '>return</span> wasp<span style='color:#308080; '>.</span>coherent<span style='color:#308080; '>(</span><span style='color:#308080; '>)</span>

<span style='color:#200080; font-weight:bold; '>def</span> getReasonsForCheckFailure<span style='color:#308080; '>(</span><span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#33cc33; '>#In case of failure compute the clause</span>
    <span style='color:#200080; font-weight:bold; '>global</span> answer
    reasons<span style='color:#308080; '>=</span><span style='color:#308080; '>[</span><span style='color:#308080; '>[</span><span style='color:#44aadd; '>-</span>answer<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span> <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms<span style='color:#308080; '>]</span><span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>return</span> wasp<span style='color:#308080; '>.</span>createReasonsForCheckFailure<span style='color:#308080; '>(</span>reasons<span style='color:#308080; '>)</span>
</pre>


<p>Consider again the following simple encoding</p>
    <pre><code>{a;b;c;d}.</code> </pre>
<p>We want to lazily instantiate the following weak constraints</p>
<pre><code>
:~ not a. [1@1,a]
:~ not b. [1@1,b]
:~ not c. [1@1,c]
:~ not d. [1@1,d]
</code></pre>
</p>

<p>One possible solution is the following</p>
<pre style='color:#000020;background:#f6f8ff;'><span style='color:#200080; font-weight:bold; '>import</span> wasp

answer <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>]</span><span style='color:#308080; '>;</span> atoms <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>]</span>

<span style='color:#200080; font-weight:bold; '>def</span> addedVarName<span style='color:#308080; '>(</span>var<span style='color:#308080; '>,</span> name<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> atoms
    atoms<span style='color:#308080; '>.</span>append<span style='color:#308080; '>(</span>var<span style='color:#308080; '>)</span>

<span style='color:#200080; font-weight:bold; '>def</span> addWeakConstraints<span style='color:#308080; '>(</span><span style='color:#44aadd; '>*</span>answer_set<span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> answer
    answer <span style='color:#308080; '>=</span> answer_set
    soft <span style='color:#308080; '>=</span> <span style='color:#308080; '>[</span><span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span> <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> answer_set<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span> <span style='color:#44aadd; '>&lt;</span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>return</span> wasp<span style='color:#308080; '>.</span>createWeakConstraints<span style='color:#308080; '>(</span>soft<span style='color:#308080; '>)</span>

<span style='color:#200080; font-weight:bold; '>def</span> addWeightsForWeakConstraints<span style='color:#308080; '>(</span><span style='color:#308080; '>)</span><span style='color:#308080; '>:</span>
    <span style='color:#200080; font-weight:bold; '>global</span> answer
    weights<span style='color:#308080; '>=</span><span style='color:#308080; '>[</span><span style='color:#008c00; '>1</span> <span style='color:#200080; font-weight:bold; '>for</span> i <span style='color:#200080; font-weight:bold; '>in</span> atoms <span style='color:#200080; font-weight:bold; '>if</span> answer<span style='color:#308080; '>[</span>i<span style='color:#308080; '>]</span> <span style='color:#44aadd; '>&lt;</span> <span style='color:#008c00; '>0</span><span style='color:#308080; '>]</span>
    <span style='color:#200080; font-weight:bold; '>return</span> wasp<span style='color:#308080; '>.</span>createWeights<span style='color:#308080; '>(</span>weights<span style='color:#308080; '>)</span>
</pre>

</body>
</html>

